---
layout: post
title: "[C] 정규표현식 사용(regex.h)"
---

프로젝트를 하면서 C언어에서 정규표현식을 사용해야 했던 적이 있다. 그 당시 C++ boost를 사용하지 않고 리눅스에서 기본적으로 제공된 라이브러리를 사용했었다.  구현도 편했고, 옛날 리눅스 시스템에서도 돌아간다는 전제로 사용했던 것 같다.

하지만 지금 코딩을 배우는 입장이라고 생각하면 boost를 쓰는것이 낫다고 생각된다. 라이브러리를 적절하게 사용하는 것도 능력이 되니깐..... 당시 사용했던 정규표현식을 '혹시라도' 다시 사용할지 몰라 기록하는 차원에서 정리하였다. 스스로 정리하였으므로 자세한 내용(함수 인자 등)은 검색을 통해 찾길 바란다.

정규표현식이 동작하는 대략적인 순서는 아래와 같다.

1. 패턴을 정의한다.
2. 패턴을 컴파일 한다.
3. 문자열과 패턴을 매치한다.
4. 패턴이 일치할 경우 어떠한 일을 한다.

정규표현식을 사용하기 위해 사용되는 헤더는 아래와 같다.

{% highlight c %}
#include <regex.h>
#include <libgen.h>
{% endhighlight %}
구현은 아래와 같다.(컴파일 해본건 아니라 문법 오류가 발생할 수 있다)

{% highlight c %}
void main()
{
    regex_t regex;
    regmatch_t matches[20]; // 정규표현식 괄호() 로 지정한 데이터 개수
    const char *pattern = ""; // 패턴을 여기에 정의
    char buf[256]=""; //처리할 문자열을 여기에 정의
    int result;
    
    result = regcomp( ®ex, pattern, REG_EXTENDED ); //패턴을 컴파일
    if( result != 0 ){
        return ; // 패턴 컴파일에 실패했을 때 처리
    }

    if( regexec( ®ex, buf, 20, matches, 0 ) == 0 ){
        // 패턴이 일치할 경우 처리할 명령
        // 이 때 데이터 사용 방법은 아래와 같다.(패턴이 1부터 시작하는 걸로 기억한다)
        // matches[1].rm_so : 패턴이 발견된 시작 위치
        // matches[1].rm_eo: 해당 패턴이 끝나는 위치
        // strncpy() 등을 통해 복사할 때 길이는
        //'matches[1].rm_eo-matches[1].rm_so' 로 계산해주면 된다.  
    }
    regfree( ®ex ); // 컴파일한 결과를 해제 함
} 
{% endhighlight %}

당시에는 정규표현식을 통해 하나의 문자열만 처리하는 것이 아닌, 여러 문자열을 반복문을 통해서 처리했던 적이 있다. 그 과정에서 몇몇 파일들에 대해서 'killed'라는 메세지가 뜨고 종료되는 것을 확인하였다.(프로그램에서 출력하는 메세지가 아니었다) 뿐만 아니라 분석 속도도 엄청 느렸었다.

killed 가 발생하는 이유에 대해서 검색해보니, 프로그램이 메모리를 너무 크게 생성되면 운영체제에서 해당 프로세스를 강제로 종료시시킨다는 것이었다. 그래서 확인해보니 regcomp()를 실행한 다음에 regfree() 를 사용하지 않아서 종료가 되는 것을 확인할 수 있었다. 나는 regcomp()가 반복적으로 동작하면 기존의 데이터는 사라지고 그 자리에 새로운 결과를 저장하는 줄 알았는데 그게 아니었나보다. 그래서 문제는 해결할 수 있었다.

그럼에도 불구하고 몇몇 파일에 대해서 같은 오류가 발생하는 것이었다. 반복문 내에서 메모리를 할당 할 수 있는 요소들은 없었다고 생각했기 때문에 고민이 길어질 수 밖에 없었다. 그 결과 패턴을 컴파일하는 regcomp() 을 반복문 밖에서 빼내었을 때 문제가 해결되었다(당시 내가 수행하고자 하는 내용과 유사한 예제 코드가 없어서 코드 그대로를 복사한 잘못이 컷다). 패턴 컴파일은 한번만 수행되도 문제가 없으며, 이 과정에서도 반복적으로 실행할 경우 같은 주소가 아닌 다른 주소에 새로 할당을 해서 그런것 같다.

결과적으로 이 과정을 통해서 메모리 할당을 하면 반드시 해제해주는 것이 필요하는걸 뼈저리게 느꼈다. 뿐만 아니라 내가 기존에 알지 못했던 새로운 라이브러리를 사용하면서 많은 것을 배울 수 있다. 아직 갈길이 멀다.

_-- 블로그를 옮기면서 2016년 11월 작성한 글_